# 生成AIにおいてのプロンプト(Prompt)最適化

概要：進化計算を使って、生成AIのプロンプトの最適化を行う。

## 研究背景

生成AIは現在急速に発展していて、生成AIを利用している人が段々増加している。そして、生成AIの生成結果にプロンプトからの影響が大きい。一方、生成AIの利用者において、正しいプロンプトを作成するのは難しいことになる。もしユーザから入力した初期プロンプトに対して最適化できれば、プロンプトの品質を向上できると考えられる。　

## 研究方法（研究ポイント）　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　

1. **プロンプトのembedding（埋め込み）化**
  
  プロンプトの最適化に対して様々な手法がある。例えば、モデルからプロンプトの候補を生成し、候補の中に最適のプロンプトを選択する（[LARGE LANGUAGE MODELS ARE HUMAN-LEVEL PROMPT ENGINEERS](https://arxiv.org/pdf/2211.01910.pdf)）。特定のタスクに作成されたembedding列に対して、最適化・調整をする（[汎用言語モデル学習のためのプロンプト最適化](https://www.jstage.jst.go.jp/article/pjsai/JSAI2023/0/JSAI2023_1T3GS605/_pdf)）。プロンプトの最適化に対して他の方法も様々ある。
  
  プロンプトは文字列になっているので、「進化計算」で扱いたい場合はベクトルに変換する必要があると思う。単語や語句が実ベクトル空間上に位置づけられることは単語や語句のembedding（埋め込み）化とも言われる。また、プロンプトのembedding化をする前にプロンプトのトークナイゼーション（Tokenization）という処理がある。トークナイゼーションとは文章を単語（トークン）に分解するトークナイズを行い、コンピューターが処理できる最小単位に変換することである。トークナイゼーションの処理があるため、個体のリンゲージ同定が必要ないと考えられる。
  
  > 例：あるプロンプトは12個のトークン（単語）があり：[cat，fox，mouse，run，after, is，chase，rabbit，kid，play，with，the]。こちらの単語はembeddingを通して下記のようにベクトルで表示できる。
  
  ```例：あるプロンプトは[cat，fox，mouse，run，after,
  cat = [ 1 0 0 0 0 0 0 0 0 0 0 0]
  fox = [ 0 1 0 0 0 0 0 0 0 0 0 0]
  mouse = [ 0 0 1 0 0 0 0 0 0 0 0 0]
  run = [ 0 0 0 1 0 0 0 0 0 0 0 0]
  after = [0 0 0 0 1 0 0 0 0 0 0 0]
  is = [ 0 0 0 0 0 0 1 0 0 0 0 0]
  chase = [ 0 0 0 0 0 0 1 0 0 0 0 0]
  rabbit = [ 0 0 0 0 0 0 0 1 0 0 0 0]
  kid = [ 0 0 0 0 0 0 0 0 1 0 0 0]
  play = [ 0 0 0 0 0 0 0 0 0 1 0 0]
  with = [ 0 0 0 0 0 0 0 0 0 0 1 0]
  the = [ 0 0 0 0 0 0 0 0 0 0 0 1]
  ```
  
2. **近傍生成**
  
  進化計算において、解の更新するために近傍生成が必要がある。こちらの考えはランタムにembeddingしたトークンを選択し、選択したトークンに進化計算を使って近傍を生成する。新しいベクトル列を生成する。
  
3. **結果(f(x))の評価と更新**
  
  進化計算でプロンプトの最適化を行う時にAIモデルの出力を評価する評価関数値f(x)が必要である。そして、評価値よりX（embeddingしたプロンプト）を更新するかどうか判断する。評価関数値の計算に関してはこちら事前に用意した訓練データセット（例：[GSM8K](https://paperswithcode.com/dataset/gsm8k)など）で生成結果を評価しようと思っている。例えば、生成結果と訓練データセットの正解との**コサイン類似度**を評価値として評価する。
  
4. **LLM（Bert、GPT、Llama2）の最適化問題をBBO問題として扱う**
  
  大規模な言語モデル（LLM）の学習には、多くの学習時間とハードウェアコストがかかるため、モデルの内部調整については考えていない。 モデルの内部構造に手を入れる必要はないと考えている。進化計算でプロンプトを最適化する場合はブラックボックス最適化問題（BBO）として扱えると考えている。
